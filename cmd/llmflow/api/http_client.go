// Code generated by kun; DO NOT EDIT.
// github.com/RussellLuo/kun

package api

import (
	"context"
	"fmt"
	"net/http"
	"net/url"
	"strings"

	"github.com/RussellLuo/kun/pkg/httpcodec"
	"github.com/RussellLuo/orchestrator"
)

type HTTPClient struct {
	codecs     httpcodec.Codecs
	httpClient *http.Client
	scheme     string
	host       string
	pathPrefix string
}

func NewHTTPClient(codecs httpcodec.Codecs, httpClient *http.Client, baseURL string) (*HTTPClient, error) {
	u, err := url.Parse(baseURL)
	if err != nil {
		return nil, err
	}
	return &HTTPClient{
		codecs:     codecs,
		httpClient: httpClient,
		scheme:     u.Scheme,
		host:       u.Host,
		pathPrefix: strings.TrimSuffix(u.Path, "/"),
	}, nil
}

func (c *HTTPClient) DeleteFlow(ctx context.Context, name string) (err error) {
	codec := c.codecs.EncodeDecoder("DeleteFlow")

	path := fmt.Sprintf("/flows/%s",
		codec.EncodeRequestParam("name", name)[0],
	)
	u := &url.URL{
		Scheme: c.scheme,
		Host:   c.host,
		Path:   c.pathPrefix + path,
	}

	_req, err := http.NewRequestWithContext(ctx, "DELETE", u.String(), nil)
	if err != nil {
		return err
	}
	for _, v := range codec.EncodeRequestParam("__", nil) {
		_req.Header.Add("Authorization", v)
	}

	_resp, err := c.httpClient.Do(_req)
	if err != nil {
		return err
	}
	defer _resp.Body.Close()

	if _resp.StatusCode < http.StatusOK || _resp.StatusCode > http.StatusNoContent {
		var respErr error
		err := codec.DecodeFailureResponse(_resp.Body, &respErr)
		if err == nil {
			err = respErr
		}
		return err
	}

	return nil
}

func (c *HTTPClient) DeleteTool(ctx context.Context, group string, typ string) (err error) {
	codec := c.codecs.EncodeDecoder("DeleteTool")

	path := fmt.Sprintf("/tools/%s",
		codec.EncodeRequestParam("group", group)[0],
	)
	u := &url.URL{
		Scheme: c.scheme,
		Host:   c.host,
		Path:   c.pathPrefix + path,
	}

	reqBody := struct {
		Typ string `json:"typ"`
	}{
		Typ: typ,
	}
	reqBodyReader, headers, err := codec.EncodeRequestBody(&reqBody)
	if err != nil {
		return err
	}

	_req, err := http.NewRequestWithContext(ctx, "DELETE", u.String(), reqBodyReader)
	if err != nil {
		return err
	}

	for k, v := range headers {
		_req.Header.Set(k, v)
	}
	for _, v := range codec.EncodeRequestParam("__", nil) {
		_req.Header.Add("Authorization", v)
	}

	_resp, err := c.httpClient.Do(_req)
	if err != nil {
		return err
	}
	defer _resp.Body.Close()

	if _resp.StatusCode < http.StatusOK || _resp.StatusCode > http.StatusNoContent {
		var respErr error
		err := codec.DecodeFailureResponse(_resp.Body, &respErr)
		if err == nil {
			err = respErr
		}
		return err
	}

	return nil
}

func (c *HTTPClient) GetFlow(ctx context.Context, name string) (definition map[string]any, err error) {
	codec := c.codecs.EncodeDecoder("GetFlow")

	path := fmt.Sprintf("/flows/%s",
		codec.EncodeRequestParam("name", name)[0],
	)
	u := &url.URL{
		Scheme: c.scheme,
		Host:   c.host,
		Path:   c.pathPrefix + path,
	}

	_req, err := http.NewRequestWithContext(ctx, "GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	for _, v := range codec.EncodeRequestParam("__", nil) {
		_req.Header.Add("Authorization", v)
	}

	_resp, err := c.httpClient.Do(_req)
	if err != nil {
		return nil, err
	}
	defer _resp.Body.Close()

	if _resp.StatusCode < http.StatusOK || _resp.StatusCode > http.StatusNoContent {
		var respErr error
		err := codec.DecodeFailureResponse(_resp.Body, &respErr)
		if err == nil {
			err = respErr
		}
		return nil, err
	}

	respBody := &GetFlowResponse{}
	err = codec.DecodeSuccessResponse(_resp.Body, respBody.Body())
	if err != nil {
		return nil, err
	}
	return respBody.Definition, nil
}

func (c *HTTPClient) GetSchemas(ctx context.Context) (schemas map[string]any, err error) {
	codec := c.codecs.EncodeDecoder("GetSchemas")

	path := "/schemas"
	u := &url.URL{
		Scheme: c.scheme,
		Host:   c.host,
		Path:   c.pathPrefix + path,
	}

	_req, err := http.NewRequestWithContext(ctx, "GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	for _, v := range codec.EncodeRequestParam("__", nil) {
		_req.Header.Add("Authorization", v)
	}

	_resp, err := c.httpClient.Do(_req)
	if err != nil {
		return nil, err
	}
	defer _resp.Body.Close()

	if _resp.StatusCode < http.StatusOK || _resp.StatusCode > http.StatusNoContent {
		var respErr error
		err := codec.DecodeFailureResponse(_resp.Body, &respErr)
		if err == nil {
			err = respErr
		}
		return nil, err
	}

	respBody := &GetSchemasResponse{}
	err = codec.DecodeSuccessResponse(_resp.Body, respBody.Body())
	if err != nil {
		return nil, err
	}
	return respBody.Schemas, nil
}

func (c *HTTPClient) GetTools(ctx context.Context) (groups []string, tools map[string][]Tool, err error) {
	codec := c.codecs.EncodeDecoder("GetTools")

	path := "/tools"
	u := &url.URL{
		Scheme: c.scheme,
		Host:   c.host,
		Path:   c.pathPrefix + path,
	}

	_req, err := http.NewRequestWithContext(ctx, "GET", u.String(), nil)
	if err != nil {
		return nil, nil, err
	}
	for _, v := range codec.EncodeRequestParam("__", nil) {
		_req.Header.Add("Authorization", v)
	}

	_resp, err := c.httpClient.Do(_req)
	if err != nil {
		return nil, nil, err
	}
	defer _resp.Body.Close()

	if _resp.StatusCode < http.StatusOK || _resp.StatusCode > http.StatusNoContent {
		var respErr error
		err := codec.DecodeFailureResponse(_resp.Body, &respErr)
		if err == nil {
			err = respErr
		}
		return nil, nil, err
	}

	respBody := &GetToolsResponse{}
	err = codec.DecodeSuccessResponse(_resp.Body, respBody.Body())
	if err != nil {
		return nil, nil, err
	}
	return respBody.Groups, respBody.Tools, nil
}

func (c *HTTPClient) RunFlow(ctx context.Context, name string, input map[string]any) (output map[string]any, err error) {
	codec := c.codecs.EncodeDecoder("RunFlow")

	path := fmt.Sprintf("/flows/%s:run",
		codec.EncodeRequestParam("name", name)[0],
	)
	u := &url.URL{
		Scheme: c.scheme,
		Host:   c.host,
		Path:   c.pathPrefix + path,
	}

	reqBody := input
	reqBodyReader, headers, err := codec.EncodeRequestBody(&reqBody)
	if err != nil {
		return nil, err
	}

	_req, err := http.NewRequestWithContext(ctx, "POST", u.String(), reqBodyReader)
	if err != nil {
		return nil, err
	}

	for k, v := range headers {
		_req.Header.Set(k, v)
	}
	for _, v := range codec.EncodeRequestParam("__", nil) {
		_req.Header.Add("Authorization", v)
	}

	_resp, err := c.httpClient.Do(_req)
	if err != nil {
		return nil, err
	}
	defer _resp.Body.Close()

	if _resp.StatusCode < http.StatusOK || _resp.StatusCode > http.StatusNoContent {
		var respErr error
		err := codec.DecodeFailureResponse(_resp.Body, &respErr)
		if err == nil {
			err = respErr
		}
		return nil, err
	}

	respBody := &RunFlowResponse{}
	err = codec.DecodeSuccessResponse(_resp.Body, respBody.Body())
	if err != nil {
		return nil, err
	}
	return respBody.Output, nil
}

func (c *HTTPClient) TestFlow(ctx context.Context, name string, input map[string]any) (event orchestrator.Event, err error) {
	codec := c.codecs.EncodeDecoder("TestFlow")

	path := fmt.Sprintf("/flows/%s:test",
		codec.EncodeRequestParam("name", name)[0],
	)
	u := &url.URL{
		Scheme: c.scheme,
		Host:   c.host,
		Path:   c.pathPrefix + path,
	}

	reqBody := input
	reqBodyReader, headers, err := codec.EncodeRequestBody(&reqBody)
	if err != nil {
		return orchestrator.Event{}, err
	}

	_req, err := http.NewRequestWithContext(ctx, "POST", u.String(), reqBodyReader)
	if err != nil {
		return orchestrator.Event{}, err
	}

	for k, v := range headers {
		_req.Header.Set(k, v)
	}
	for _, v := range codec.EncodeRequestParam("__", nil) {
		_req.Header.Add("Authorization", v)
	}

	_resp, err := c.httpClient.Do(_req)
	if err != nil {
		return orchestrator.Event{}, err
	}
	defer _resp.Body.Close()

	if _resp.StatusCode < http.StatusOK || _resp.StatusCode > http.StatusNoContent {
		var respErr error
		err := codec.DecodeFailureResponse(_resp.Body, &respErr)
		if err == nil {
			err = respErr
		}
		return orchestrator.Event{}, err
	}

	respBody := &TestFlowResponse{}
	err = codec.DecodeSuccessResponse(_resp.Body, respBody.Body())
	if err != nil {
		return orchestrator.Event{}, err
	}
	return respBody.Event, nil
}

func (c *HTTPClient) UpsertFlow(ctx context.Context, name string, definition map[string]any) (err error) {
	codec := c.codecs.EncodeDecoder("UpsertFlow")

	path := fmt.Sprintf("/flows/%s",
		codec.EncodeRequestParam("name", name)[0],
	)
	u := &url.URL{
		Scheme: c.scheme,
		Host:   c.host,
		Path:   c.pathPrefix + path,
	}

	reqBody := definition
	reqBodyReader, headers, err := codec.EncodeRequestBody(&reqBody)
	if err != nil {
		return err
	}

	_req, err := http.NewRequestWithContext(ctx, "PUT", u.String(), reqBodyReader)
	if err != nil {
		return err
	}

	for k, v := range headers {
		_req.Header.Set(k, v)
	}
	for _, v := range codec.EncodeRequestParam("__", nil) {
		_req.Header.Add("Authorization", v)
	}

	_resp, err := c.httpClient.Do(_req)
	if err != nil {
		return err
	}
	defer _resp.Body.Close()

	if _resp.StatusCode < http.StatusOK || _resp.StatusCode > http.StatusNoContent {
		var respErr error
		err := codec.DecodeFailureResponse(_resp.Body, &respErr)
		if err == nil {
			err = respErr
		}
		return err
	}

	return nil
}

func (c *HTTPClient) UpsertTool(ctx context.Context, group string, typ string, tool Tool) (err error) {
	codec := c.codecs.EncodeDecoder("UpsertTool")

	path := fmt.Sprintf("/tools/%s",
		codec.EncodeRequestParam("group", group)[0],
	)
	u := &url.URL{
		Scheme: c.scheme,
		Host:   c.host,
		Path:   c.pathPrefix + path,
	}

	reqBody := struct {
		Typ  string `json:"typ"`
		Tool Tool   `json:"tool"`
	}{
		Typ:  typ,
		Tool: tool,
	}
	reqBodyReader, headers, err := codec.EncodeRequestBody(&reqBody)
	if err != nil {
		return err
	}

	_req, err := http.NewRequestWithContext(ctx, "PUT", u.String(), reqBodyReader)
	if err != nil {
		return err
	}

	for k, v := range headers {
		_req.Header.Set(k, v)
	}
	for _, v := range codec.EncodeRequestParam("__", nil) {
		_req.Header.Add("Authorization", v)
	}

	_resp, err := c.httpClient.Do(_req)
	if err != nil {
		return err
	}
	defer _resp.Body.Close()

	if _resp.StatusCode < http.StatusOK || _resp.StatusCode > http.StatusNoContent {
		var respErr error
		err := codec.DecodeFailureResponse(_resp.Body, &respErr)
		if err == nil {
			err = respErr
		}
		return err
	}

	return nil
}
