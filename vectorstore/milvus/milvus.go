package milvus

import (
	"context"
	"fmt"
	"strings"

	"github.com/go-aie/llmflow"
	"github.com/go-aie/xslices"
	"github.com/milvus-io/milvus-sdk-go/v2/client"
	"github.com/milvus-io/milvus-sdk-go/v2/entity"
)

const (
	pkName, idName, textName, vectorName, sourceIDName, extraName = "pk", "id", "text", "vector", "source_id", "extra"
)

type Config struct {
	// Addr is the address of the Milvus server.
	// Defaults to "localhost:19530".
	Addr string `structool:"addr"`

	// CollectionName is the collection name.
	// This field is required.
	CollectionName string `structool:"collection_name"`

	// Dim is the vector/embedding dimension.
	// Defaults to 1536 (the dimension generated by OpenAI's Embedding API).
	Dim int `structool:"dim"`
}

func (cfg *Config) init() {
	if cfg.Addr == "" {
		cfg.Addr = "localhost:19530"
	}
	if cfg.Dim == 0 {
		cfg.Dim = 1536
	}
}

type Milvus struct {
	client client.Client
	cfg    *Config
}

func New(cfg *Config) (*Milvus, error) {
	cfg.init()
	ctx := context.Background()

	c, err := client.NewGrpcClient(ctx, cfg.Addr)
	if err != nil {
		return nil, err
	}

	m := &Milvus{
		client: c,
		cfg:    cfg,
	}

	if err := m.createAndLoadCollection(ctx, false); err != nil {
		return nil, err
	}

	return m, nil
}

func (m *Milvus) Upsert(ctx context.Context, documents []*llmflow.Document) error {
	var idList []string
	var textList []string
	var vectorList [][]float32
	var sourceIDList []string
	var extraList []string
	for _, doc := range documents {
		idList = append(idList, doc.ID)
		textList = append(textList, doc.Text)
		vectorList = append(vectorList, xslices.Float64ToNumber[float32](doc.Vector))
		sourceIDList = append(sourceIDList, doc.Metadata.SourceID)
		extraList = append(extraList, doc.Extra)
	}

	idCol := entity.NewColumnVarChar(idName, idList)
	textCol := entity.NewColumnVarChar(textName, textList)
	vectorCol := entity.NewColumnFloatVector(vectorName, m.cfg.Dim, vectorList)
	sourceIDCol := entity.NewColumnVarChar(sourceIDName, sourceIDList)
	extraCol := entity.NewColumnVarChar(extraName, extraList)

	_, err := m.client.Insert(ctx, m.cfg.CollectionName, "", idCol, textCol, vectorCol, sourceIDCol, extraCol)
	return err
}

// Query searches similarities of the given vector with default consistency level.
func (m *Milvus) Query(ctx context.Context, vector llmflow.Vector, topK int, minScore float64) ([]*llmflow.Similarity, error) {
	float32Vector := xslices.Float64ToNumber[float32](vector)
	vec2search := []entity.Vector{
		entity.FloatVector(float32Vector),
	}

	param, _ := entity.NewIndexFlatSearchParam()
	result, err := m.client.Search(
		ctx,
		m.cfg.CollectionName,
		nil,
		"",
		[]string{idName, textName, sourceIDName, extraName},
		vec2search,
		vectorName,
		entity.L2,
		topK,
		param,
	)
	if err != nil {
		return nil, err
	}

	if len(result) == 0 {
		return []*llmflow.Similarity{}, nil // ensure `[]` in JSON if empty
	}

	return constructSimilaritiesFromResult(&result[0], minScore)
}

// Delete deletes the documents belonging to the given sourceIDs.
// As a special case, empty sourceIDs means deleting all documents.
func (m *Milvus) Delete(ctx context.Context, sourceIDs ...string) error {
	// To delete all documents, we drop the old collection and create a new one.
	if len(sourceIDs) == 0 {
		if err := m.client.ReleaseCollection(ctx, m.cfg.CollectionName); err != nil {
			return err
		}
		if err := m.client.DropCollection(ctx, m.cfg.CollectionName); err != nil {
			return err
		}
		return m.createAndLoadCollection(ctx, true)
	}

	expr := fmt.Sprintf(`%s in ["%s"]`, sourceIDName, strings.Join(sourceIDs, `", "`))
	result, err := m.client.Query(ctx, m.cfg.CollectionName, nil, expr, []string{pkName})
	if err != nil {
		return err
	}

	var pkCol *entity.ColumnInt64
	for _, field := range result {
		if field.Name() == pkName {
			if c, ok := field.(*entity.ColumnInt64); ok {
				pkCol = c
			}
		}
	}

	if len(pkCol.Data()) == 0 {
		return nil
	}
	return m.client.DeleteByPks(ctx, m.cfg.CollectionName, "", pkCol)
}

func (m *Milvus) createAndLoadCollection(ctx context.Context, createNew bool) error {
	if err := m.createCollection(ctx, createNew); err != nil {
		return err
	}
	return m.client.LoadCollection(ctx, m.cfg.CollectionName, false)
}

func (m *Milvus) createCollection(ctx context.Context, createNew bool) error {
	has, err := m.client.HasCollection(ctx, m.cfg.CollectionName)
	if err != nil {
		return err
	}

	if has && !createNew {
		return nil
	}

	if has {
		_ = m.client.DropCollection(ctx, m.cfg.CollectionName)
	}

	// The collection does not exist, so we need to create one.

	schema := &entity.Schema{
		CollectionName: m.cfg.CollectionName,
		AutoID:         true,
		Fields: []*entity.Field{
			{
				Name:       pkName,
				DataType:   entity.FieldTypeInt64,
				PrimaryKey: true,
				AutoID:     true,
			},
			{
				Name:     idName,
				DataType: entity.FieldTypeVarChar,
				TypeParams: map[string]string{
					entity.TypeParamMaxLength: fmt.Sprintf("%d", 65535),
				},
			},
			{
				Name:     textName,
				DataType: entity.FieldTypeVarChar,
				TypeParams: map[string]string{
					entity.TypeParamMaxLength: fmt.Sprintf("%d", 65535),
				},
			},
			{
				Name:     vectorName,
				DataType: entity.FieldTypeFloatVector,
				TypeParams: map[string]string{
					entity.TypeParamDim: fmt.Sprintf("%d", m.cfg.Dim),
				},
			},
			{
				Name:     sourceIDName,
				DataType: entity.FieldTypeVarChar,
				TypeParams: map[string]string{
					entity.TypeParamMaxLength: fmt.Sprintf("%d", 65535),
				},
			},
			{
				Name:     extraName,
				DataType: entity.FieldTypeVarChar,
				TypeParams: map[string]string{
					entity.TypeParamMaxLength: fmt.Sprintf("%d", 65535),
				},
			},
		},
	}

	// Create collection with consistency level, which serves as the default search/query consistency level.
	if err := m.client.CreateCollection(ctx, schema, 2, client.WithConsistencyLevel(entity.ClBounded)); err != nil {
		return err
	}

	// Create index "IVF_FLAT".
	idx, err := entity.NewIndexIvfFlat(entity.L2, 128)
	if err != nil {
		return err
	}
	return m.client.CreateIndex(ctx, m.cfg.CollectionName, vectorName, idx, false)
}

func constructSimilaritiesFromResult(result *client.SearchResult, minScore float64) ([]*llmflow.Similarity, error) {
	var idCol *entity.ColumnVarChar
	var textCol *entity.ColumnVarChar
	var sourceIDCol *entity.ColumnVarChar
	var extraCol *entity.ColumnVarChar

	for _, field := range result.Fields {
		switch field.Name() {
		case idName:
			if c, ok := field.(*entity.ColumnVarChar); ok {
				idCol = c
			}
		case textName:
			if c, ok := field.(*entity.ColumnVarChar); ok {
				textCol = c
			}
		case sourceIDName:
			if c, ok := field.(*entity.ColumnVarChar); ok {
				sourceIDCol = c
			}
		case extraName:
			if c, ok := field.(*entity.ColumnVarChar); ok {
				extraCol = c
			}
		}
	}

	similarities := make([]*llmflow.Similarity, 0) // ensure `[]` in JSON if empty
	for i := 0; i < result.ResultCount; i++ {
		id, err := idCol.ValueByIdx(i)
		if err != nil {
			return nil, err
		}
		text, err := textCol.ValueByIdx(i)
		if err != nil {
			return nil, err
		}
		sourceID, err := sourceIDCol.ValueByIdx(i)
		if err != nil {
			return nil, err
		}
		extra, err := extraCol.ValueByIdx(i)
		if err != nil {
			return nil, err
		}

		// Transform Euclidean distances to similarity scores.
		//
		// Euclidean distance (L2):
		// - The Euclidean distance of two vectors is in [0, âˆž).
		// - The Euclidean distance of two normalized vectors is in [0, 2].
		// - The Euclidean distances returned by Milvus are in ascending order (the smaller, the more similar).
		// - See https://github.com/milvus-io/milvus/issues/6843.
		//
		// Similarity score (defined by OneAI):
		// - The similarity score of two normalized vectors is in [0, 1].
		// - The similarity scores returned by OneAI are in descending order (the larger, the more similar).
		//
		// Given the above information, we can get an approximate similarity score
		// from an Euclidean distance by using the following formula:
		//
		//     score = 1 - (L2 of normalized vector) / 2
		//
		originalScore := float64(result.Scores[i])
		score := 1 - originalScore/2

		if score >= minScore {
			similarities = append(similarities, &llmflow.Similarity{
				Document: &llmflow.Document{
					ID:   id,
					Text: text,
					Metadata: llmflow.Metadata{
						SourceID: sourceID,
					},
					Extra: extra,
				},
				Score: score,
			})
		}
	}

	return similarities, nil
}
